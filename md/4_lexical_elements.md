## Лексические элементы ## {#Lexical_elements}

### Комментарии ### {#Comments}

Комментарии используются для документирования кода. Существуют два способа обозначить комментарий:

1. _Строчные комментарии_ начинаются с последовательности символов `//` и ограничиваются строкой
2. _Блочные комментарии_ начинаются с символов `/*` и закрываются первой встреченной последовательностью символов `*/`

Комментарии не могу начинаться внутри [руны](#Rune_literals), [строкового литерала](#String_literals) или внутри комментария. Блочные комментарии расположенные на одной строке соединяются между собой пробелом, все другие разделяются новой строкой.

### Токены ### {#Tokens}

Токены формируют словарь языка Go. Все они разделены на четыре класса: _идентификаторы_, _ключевые слова_, _операторы и разделители_ и _литералы_. _Пустое пространство_, образованное символами пробела (U+0020) табуляция (U+0009), возврат каретки (U+000D) и новая строка (U+000A) игнорируются за исключением случаев когда они разделяют токены, которые в противном случае воспринимались как один. Помимо этого символ новой строки или конец файла могут инициировать вставку [точки с запятой](#Semicolons) лексическим анализатором. При разбиении ввода на токены, последующий токен будет являться самым длинным набором символов, воспринимаемым как действительный токен.

### Точка с запятой ### {#Semicolons}

Формальная грамматика Go использует точку с запятой `";"` для терминирования результатов. Однако исходный код написанный на Go в большенстве случаев может упускать точку с запятой, придерживаясь следующих правил.

1. Когда ввод разбит на токены, точка с запятой автоматически разместиться за последним токеном во входящей строке если токен является

    * [Идентификатором](#Identifiers)
    * Литералом [целочисленного числа](#Integer_literals), литералом [числа с плавающей точкой](#Floating-point_literals), [рунным](#Rune_literals) литералом, [строковым](#String_literals) литералом или [мнимым](#Imaginary_literals) литералом.
    * [Ключевым словом](#Keywords) `break`, `continue`, `fallthrough` или `return`
    * Одним из [операторов или разделителей](#Operators_and_Delimiters) `++`, `--`, `)`, `]`, `}`

2. Для возможности записи сложных конструкций в одну строку, точка с запятой будет вставлена перед закрывающими круглой `")"` и фигурной `"}"` скобками

Чтобы показать идиоматическое использование точки с запятой, примеры кода приведенные в данной документации используют приведенные правила

### Идентификаторы ### {#Identifiers}

Идентификаторы определяют названия программных сущностей таких как переменные и типы. Идентификаторы являются последовательностью букв и цифр. Первым символом идентификатора должна быть буква

<pre class="ebnf"><a id="identifier">identifier</a> = <a href="#letter" class="noline">letter</a> { <a href="#letter" class="noline">letter</a> | <a href="#unicode_digit" class="noline">unicode_digit</a> } .
</pre>

``` go
a
_x9
ThisVariableIsExported
αβ
```

Часть идентификаторов [предопределена](#Predeclared_identifiers) заранее.

### Ключевые слова ### {#Keywords}

Следующие ключевые слова зарезервированы и не могут использоватся как идентификаторы

``` go
break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var
```

### Операторы и разделители ### {#Operators_and_Delimiters}

Следующие последовательности символов представляют [операторы](#Operators), разделители и другие специальные токены

``` go
+    &     +=    &=     &&    ==    !=    (    )
-    |     -=    |=     ||    <     <=    [    ]
*    ^     *=    ^=     <-    >     >=    {    }
/    <<    /=    <<=    ++    =     :=    ,    ;
%    >>    %=    >>=    --    !     ...   .    :
     &^          &^=
```

### Целочисленные литералы ### {#Integer_literals}

Целочисленные литералы это последовательность цифр представляющая собой [целочисленную константу](#Constants). Для обозначения не десятичных чисел используется префиксы: `0` для восьмеричной, `0x` или `0X` для шестеричной. В шестнадцатеричных литералах, буквы `a-f` и `A-F` обозначают значения в диапазоне 10-15.

<pre class="ebnf"><a id="int_lit">int_lit</a>     = <a href="#decimal_lit" class="noline">decimal_lit</a> | <a href="#octal_lit" class="noline">octal_lit</a> | <a href="#hex_lit" class="noline">hex_lit</a> .
<a id="decimal_lit">decimal_lit</a> = ( "1" … "9" ) { <a href="#decimal_digit" class="noline">decimal_digit</a> } .
<a id="octal_lit">octal_lit</a>   = "0" { <a href="#octal_digit" class="noline">octal_digit</a> } .
<a id="hex_lit">hex_lit</a>     = "0" ( "x" | "X" ) <a href="#hex_digit" class="noline">hex_digit</a> { <a href="#hex_digit" class="noline">hex_digit</a> } .
</pre>

``` go
42
0600
0xBadFace
170141183460469231731687303715884105727
```

### Литералы чисел с плавающей точкой ### {#Floating-point_literals}

Литерал с плавающей точкой это десятеричное представление констант чисел с [плавающей точкой](###). Они имеют целую часть, десятичную точку, дробную часть и экспоненциальную часть. Целая и дробная часть образуют десятичные цифры. Экспонента представлена символом `e` или `E` за которым следует необязательный десятичный показатель. В десятичной записи может быть упущена целая или дробная часть, в экспонентной записи может быть упущена десятичная точка или показатель степени

<pre class="ebnf"><a id="float_lit">float_lit</a> = <a href="#decimals" class="noline">decimals</a> "." [ <a href="#decimals" class="noline">decimals</a> ] [ <a href="#exponent" class="noline">exponent</a> ] |
            <a href="#decimals" class="noline">decimals</a> <a href="#exponent" class="noline">exponent</a> |
            "." <a href="#decimals" class="noline">decimals</a> [ <a href="#exponent" class="noline">exponent</a> ] .
<a id="decimals">decimals</a>  = <a href="#decimal_digit" class="noline">decimal_digit</a> { <a href="#decimal_digit" class="noline">decimal_digit</a> } .
<a id="exponent">exponent</a>  = ( "e" | "E" ) [ "+" | "-" ] <a href="#decimals" class="noline">decimals</a> .
</pre>

``` go
0.
72.40
072.40  // == 72.40
2.71828
1.e+0
6.67428e-11
1E6
.25
.12345E+5
```

### Мнимые литералы ### {#Imaginary_literals}

Мнимый литерал это десятеричное представление мнимой части [констант комплексных чисел](#Constants). Он состоит из литерала [числа с плавающей точкой](#Floating-point_literals) или десятичного целого числа с символом `i` в конце

<pre class="ebnf"><a id="imaginary_lit">imaginary_lit</a> = (<a href="#decimals" class="noline">decimals</a> | <a href="#float_lit" class="noline">float_lit</a>) "i" .
</pre>

``` go
0i
011i  // == 11i
0.i
2.71828i
1.e+0i
6.67428e-11i
1E6i
.25i
.12345E+5i
```

### Рунные литералы ### {#Rune_literals}

Рунные литералы представляют [рунные константы](#Constants), целочисленные значения представляющие кодовые точки Unicode. Рунный литерал записывается как один или несколько символов размещенных в одинарные кавычки, как пример `'x'`, `'\n'`. Внутри одинарных кавычек может быть размещен любой символ кроме новой строки и неэкранированной одинарной кавычки. Одиночный символ представляет собой непосредственно кодовую точку Unicode, в то время как мультисимвольная запись может начинающаяся с обратного слэша, кодирует значение в различных форматах.

Простая форма записи представляет собой одиночным символом заключенный в одинарные кавычки. Так как исходный код в Go представляет собой набор кодовых точек Unicode закодированных в UTF-8, несколько байт закодированных в UTF-8 могут представлять один символ. Для примера знак `'a'` содержит единственный байт представляющий букву `a`, кодовую точку Unicode U+0061, шестеричное значение `0x61`, тогда как литерал `'ä'` представляет собой два байта (`0xc3` `0xa4`) представляющих `a` с тремой, кодовую точку Unicode U+00E4 и шестеричное значение `0xe4`

С помощью escape-последовательностей с обратной косой чертой можно записывать любые значения в кодировке ASCII. Есть четыре способа представления целочисленного значения в качестве числовой константы: последовательность `\x`, за которой следуют ровно две шестнадцатеричных цифры; `\u` и ровно четыре шестнадцатеричных цифры; `\U` и ровно восемь шестнадцатеричных цифр; просто обратная косая черта `\` и ровно три восьмеричных цифры. В каждом случае значение литерала — это значение, представленное указанными цифрами в соответствующей системе счисления.

Хотя все эти представления дают целочисленный результат, у них различен допустимый диапазон. Восьмеричные escape-последовательности должны представлять значение от 0 до 255 включительно. Шестнадцатеричные escape-последовательности удовлетворяют этому условию по построению. Escape-последовательности, начинающиеся с `\u` или `\U`, представляют собой кодовые-точки Юникод, поэтому некоторые значения в них недопустимы, в частности, значения выше `0x10FFFF` и замещающие половины.

Некоторые одиночные символы записанные после обратной косой черты образуют спецсимволы:

``` go
\a   U+0007 alert or bell
\b   U+0008 backspace
\f   U+000C form feed
\n   U+000A line feed or newline
\r   U+000D carriage return
\t   U+0009 horizontal tab
\v   U+000b vertical tab
\\   U+005c backslash
\'   U+0027 single quote  (valid escape only within rune literals)
\"   U+0022 double quote  (valid escape only within string literals)
```

Любые другие последовательности, начинающиеся с обратной косой черты, запрещены в рунных литералах.

<pre class="ebnf"><a id="rune_lit">rune_lit</a>         = "'" ( <a href="#unicode_value" class="noline">unicode_value</a> | <a href="#byte_value" class="noline">byte_value</a> ) "'" .
<a id="unicode_value">unicode_value</a>    = <a href="#unicode_char" class="noline">unicode_char</a> | <a href="#little_u_value" class="noline">little_u_value</a> | <a href="#big_u_value" class="noline">big_u_value</a> | <a href="#escaped_char" class="noline">escaped_char</a> .
<a id="byte_value">byte_value</a>       = <a href="#octal_byte_value" class="noline">octal_byte_value</a> | <a href="#hex_byte_value" class="noline">hex_byte_value</a> .
<a id="octal_byte_value">octal_byte_value</a> = `\` <a href="#octal_digit" class="noline">octal_digit</a> <a href="#octal_digit" class="noline">octal_digit</a> <a href="#octal_digit" class="noline">octal_digit</a> .
<a id="hex_byte_value">hex_byte_value</a>   = `\` "x" <a href="#hex_digit" class="noline">hex_digit</a> <a href="#hex_digit" class="noline">hex_digit</a> .
<a id="little_u_value">little_u_value</a>   = `\` "u" <a href="#hex_digit" class="noline">hex_digit</a> <a href="#hex_digit" class="noline">hex_digit</a> <a href="#hex_digit" class="noline">hex_digit</a> <a href="#hex_digit" class="noline">hex_digit</a> .
<a id="big_u_value">big_u_value</a>      = `\` "U" <a href="#hex_digit" class="noline">hex_digit</a> <a href="#hex_digit" class="noline">hex_digit</a> <a href="#hex_digit" class="noline">hex_digit</a> <a href="#hex_digit" class="noline">hex_digit</a>
                           <a href="#hex_digit" class="noline">hex_digit</a> <a href="#hex_digit" class="noline">hex_digit</a> <a href="#hex_digit" class="noline">hex_digit</a> <a href="#hex_digit" class="noline">hex_digit</a> .
<a id="escaped_char">escaped_char</a>     = `\` ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | `\` | "'" | `"` ) .
</pre>

``` go
'a'
'ä'
'本'
'\t'
'\000'
'\007'
'\377'
'\x07'
'\xff'
'\u12e4'
'\U00101234'
'\''         // rune literal containing single quote character
'aa'         // illegal: too many characters
'\xa'        // illegal: too few hexadecimal digits
'\0'         // illegal: too few octal digits
'\uDFFF'     // illegal: surrogate half
'\U00110000' // illegal: invalid Unicode code point
```

### Строковые литерали ### {#String_literals}

Строковый литерал представляет собой [строковую константу](#Constants), образованную путем соединения последовательности символов. Существует две формы: неинтерпретированная и интерпретированная.

Неинтерпретируемые строковые литералы представляют собой последовательности символов, заключённые в обратные кавычки ``foo``. Внутри этих кавычек допустимы все символы, кроме обратных кавычек. Значение сырого строкового литерала — это строка, составленная из непроинтерпретированных (неявно закодированных в UTF-8) символов внутри кавычек; в частности, обратная косая черта не имеет специального значения, и литерал может быть расположен на нескольких строках. Символ возврата коретки ('\r') внутри неинтерпретируемых строковых литералов отбрасываются если литерал расположен в теле интерпретируемого литерала.

Интерпретируемые строковые литералы представляют собой последовательности символов, заключённые в двойные кавычки `"bar"`. Внутри ковычек может быть расположен любой символ за исключением новой строки и неэкранированной двойной кавычки. Текст внутри ковычек образует значение литерала, и escape-последовательности интерпретируются подобно рунным литералам (за исключением того, что недопустима последовательность `\'`, но допустима `\"`). Escape-последовательности из трёх восьмеричных цифр (`\n`_nnn_) и из двух шестнадцатиричных цифр (`\x`_nn_) представляют индивидуальные _байты_ итоговой строки; все прочие escape-последовательности представляют коды (возможно, мультибайтовые) индивидуальных _символов_ в кодировке UTF-8. Таким образом, внутри строкового литерала последовательности `\377` и `\xFF` обозначают один байт со значением `0xFF`=255, в то время как `ÿ`, `\u00FF`, `\U000000FF` и `\xc3\xbf` представляют два байта `0xc3` `0xbf` кода символа U+00FF в кодировке UTF-8. 

<pre class="ebnf"><a id="string_lit">string_lit</a>             = <a href="#raw_string_lit" class="noline">raw_string_lit</a> | <a href="#interpreted_string_lit" class="noline">interpreted_string_lit</a> .
<a id="raw_string_lit">raw_string_lit</a>         = "`" { <a href="#unicode_char" class="noline">unicode_char</a> | <a href="#newline" class="noline">newline</a> } "`" .
<a id="interpreted_string_lit">interpreted_string_lit</a> = `"` { <a href="#unicode_value" class="noline">unicode_value</a> | <a href="#byte_value" class="noline">byte_value</a> } `"` .
</pre>

``` go
`abc`                // значение аналогично "abc"
`\n
\n`                  // значение аналогично "\\n\n\\n"
"\n"
"\""                 // значение аналогично `"`
"Hello, world!\n"
"日本語"
"\u65e5本\U00008a9e"
"\xff\u00FF"
"\uD800"             // недопустимое значение: половина суррогатной пары
"\U00110000"         // недопустимое значение: недействительная кодовая-точка Юникод
```

Все эти примеры представляют одну и ту же строку:

``` go
"日本語"                                 // текст в кодировке UTF-8 
`日本語`                                 // неинтерпретируемый текст в кодировке UTF-8 
"\u65e5\u672c\u8a9e"                    // кодовые-точки Юникод в явном виде
"\U000065e5\U0000672c\U00008a9e"        // кодовые-точки Юникод в явном виде
"\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e"  // байты в кодировке UTF-8 в явном виде
```

Если в исходнои коде представлен символ в виде двух кодовых-точек, такой как составной символ из буквы и диакритического символа, то результатом выполнения будет ошибка, если этот символ расположен внутри рунного литерала (т.к. это не единичная кодовая точка), и отображен в виде двух кодовых-точек, если будет расположен внутри строкового литерала.
